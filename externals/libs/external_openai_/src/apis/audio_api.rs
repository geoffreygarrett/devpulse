/*
 * OpenAI API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::configuration;
pub use super::Error;
use crate::{apis::ResponseContent, models};
use cached::proc_macro::cached;
use cached::Cached;
use cached::SizedCache;
use derive_builder::Builder;
use reqwest;
use serde::{Deserialize, Serialize};
use tracing::{debug, error, info, trace, warn};
/// struct for passing parameters to the method [`create_speech`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateSpeechParams {
    pub create_speech_request: models::CreateSpeechRequest,
}

impl CreateSpeechParams {
    pub fn builder() -> CreateSpeechParamsBuilder {
        CreateSpeechParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_transcription`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateTranscriptionParams {
    /// The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
    pub file: std::path::PathBuf,
    pub model: models::CreateTranscriptionRequestModel,
    /// The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
    pub language: Option<String>,
    /// An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
    pub prompt: Option<String>,
    /// The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
    pub response_format: Option<String>,
    /// The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the
    pub temperature: Option<f64>,
    /// The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamp
    pub timestamp_granularities_left_square_bracket_right_square_bracket: Option<Vec<String>>,
}

impl CreateTranscriptionParams {
    pub fn builder() -> CreateTranscriptionParamsBuilder {
        CreateTranscriptionParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_translation`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateTranslationParams {
    /// The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
    pub file: std::path::PathBuf,
    pub model: models::CreateTranscriptionRequestModel,
    /// An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
    pub prompt: Option<String>,
    /// The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
    pub response_format: Option<String>,
    /// The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the
    pub temperature: Option<f64>,
}

impl CreateTranslationParams {
    pub fn builder() -> CreateTranslationParamsBuilder {
        CreateTranslationParamsBuilder::default()
    }
}

/// struct for typed errors of method [`create_speech`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSpeechError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_transcription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_translation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTranslationError {
    UnknownValue(serde_json::Value),
}

#[tracing::instrument]
pub async fn create_speech(
    configuration: &configuration::Configuration, params: CreateSpeechParams,
) -> Result<std::path::PathBuf, Error<CreateSpeechError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_speech_request = params.create_speech_request;

    debug!("Calling create_speech...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/audio/speech", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_speech_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSpeechError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_transcription(
    configuration: &configuration::Configuration, params: CreateTranscriptionParams,
) -> Result<models::CreateTranscription200Response, Error<CreateTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let file = params.file;
    let model = params.model;
    let language = params.language;
    let prompt = params.prompt;
    let response_format = params.response_format;
    let temperature = params.temperature;
    let timestamp_granularities_left_square_bracket_right_square_bracket =
        params.timestamp_granularities_left_square_bracket_right_square_bracket;

    debug!("Calling create_transcription...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/audio/transcriptions", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    local_var_form = local_var_form.text("model", model.to_string());
    if let Some(local_var_param_value) = language {
        local_var_form = local_var_form.text("language", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = prompt {
        local_var_form = local_var_form.text("prompt", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = response_format {
        local_var_form = local_var_form.text("response_format", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = temperature {
        local_var_form = local_var_form.text("temperature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) =
        timestamp_granularities_left_square_bracket_right_square_bracket
    {
        local_var_form = local_var_form.text(
            "timestamp_granularities[]",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateTranscriptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_translation(
    configuration: &configuration::Configuration, params: CreateTranslationParams,
) -> Result<models::CreateTranslation200Response, Error<CreateTranslationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let file = params.file;
    let model = params.model;
    let prompt = params.prompt;
    let response_format = params.response_format;
    let temperature = params.temperature;

    debug!("Calling create_translation...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/audio/translations", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    local_var_form = local_var_form.text("model", model.to_string());
    if let Some(local_var_param_value) = prompt {
        local_var_form = local_var_form.text("prompt", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = response_format {
        local_var_form = local_var_form.text("response_format", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = temperature {
        local_var_form = local_var_form.text("temperature", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateTranslationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
