/*
 * OpenAI API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::configuration;
pub use super::Error;
use crate::{apis::ResponseContent, models};
use cached::proc_macro::cached;
use cached::Cached;
use cached::SizedCache;
use derive_builder::Builder;
use reqwest;
use serde::{Deserialize, Serialize};
use tracing::{debug, error, info, trace, warn};
/// struct for passing parameters to the method [`cancel_run`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CancelRunParams {
    /// The ID of the thread to which this run belongs.
    pub thread_id: String,
    /// The ID of the run to cancel.
    pub run_id: String,
}

impl CancelRunParams {
    pub fn builder() -> CancelRunParamsBuilder {
        CancelRunParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_assistant`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateAssistantParams {
    pub create_assistant_request: models::CreateAssistantRequest,
}

impl CreateAssistantParams {
    pub fn builder() -> CreateAssistantParamsBuilder {
        CreateAssistantParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_message`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateMessageParams {
    /// The ID of the [thread](/docs/api-reference/threads) to create a message for.
    pub thread_id: String,
    pub create_message_request: models::CreateMessageRequest,
}

impl CreateMessageParams {
    pub fn builder() -> CreateMessageParamsBuilder {
        CreateMessageParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_run`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateRunParams {
    /// The ID of the thread to run.
    pub thread_id: String,
    pub create_run_request: models::CreateRunRequest,
}

impl CreateRunParams {
    pub fn builder() -> CreateRunParamsBuilder {
        CreateRunParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_thread`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateThreadParams {
    pub create_thread_request: Option<models::CreateThreadRequest>,
}

impl CreateThreadParams {
    pub fn builder() -> CreateThreadParamsBuilder {
        CreateThreadParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`create_thread_and_run`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct CreateThreadAndRunParams {
    pub create_thread_and_run_request: models::CreateThreadAndRunRequest,
}

impl CreateThreadAndRunParams {
    pub fn builder() -> CreateThreadAndRunParamsBuilder {
        CreateThreadAndRunParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`delete_assistant`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct DeleteAssistantParams {
    /// The ID of the assistant to delete.
    pub assistant_id: String,
}

impl DeleteAssistantParams {
    pub fn builder() -> DeleteAssistantParamsBuilder {
        DeleteAssistantParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`delete_message`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct DeleteMessageParams {
    /// The ID of the thread to which this message belongs.
    pub thread_id: String,
    /// The ID of the message to delete.
    pub message_id: String,
}

impl DeleteMessageParams {
    pub fn builder() -> DeleteMessageParamsBuilder {
        DeleteMessageParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`delete_thread`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct DeleteThreadParams {
    /// The ID of the thread to delete.
    pub thread_id: String,
}

impl DeleteThreadParams {
    pub fn builder() -> DeleteThreadParamsBuilder {
        DeleteThreadParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`get_assistant`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct GetAssistantParams {
    /// The ID of the assistant to retrieve.
    pub assistant_id: String,
}

impl GetAssistantParams {
    pub fn builder() -> GetAssistantParamsBuilder {
        GetAssistantParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`get_message`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct GetMessageParams {
    /// The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
    pub thread_id: String,
    /// The ID of the message to retrieve.
    pub message_id: String,
}

impl GetMessageParams {
    pub fn builder() -> GetMessageParamsBuilder {
        GetMessageParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`get_run`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct GetRunParams {
    /// The ID of the [thread](/docs/api-reference/threads) that was run.
    pub thread_id: String,
    /// The ID of the run to retrieve.
    pub run_id: String,
}

impl GetRunParams {
    pub fn builder() -> GetRunParamsBuilder {
        GetRunParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`get_run_step`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct GetRunStepParams {
    /// The ID of the thread to which the run and run step belongs.
    pub thread_id: String,
    /// The ID of the run to which the run step belongs.
    pub run_id: String,
    /// The ID of the run step to retrieve.
    pub step_id: String,
}

impl GetRunStepParams {
    pub fn builder() -> GetRunStepParamsBuilder {
        GetRunStepParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`get_thread`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct GetThreadParams {
    /// The ID of the thread to retrieve.
    pub thread_id: String,
}

impl GetThreadParams {
    pub fn builder() -> GetThreadParamsBuilder {
        GetThreadParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`list_assistants`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ListAssistantsParams {
    /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
    pub limit: Option<i32>,
    /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
    pub order: Option<String>,
    /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
    pub after: Option<String>,
    /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
    pub before: Option<String>,
}

impl ListAssistantsParams {
    pub fn builder() -> ListAssistantsParamsBuilder {
        ListAssistantsParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`list_messages`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ListMessagesParams {
    /// The ID of the [thread](/docs/api-reference/threads) the messages belong to.
    pub thread_id: String,
    /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
    pub limit: Option<i32>,
    /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
    pub order: Option<String>,
    /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
    pub after: Option<String>,
    /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
    pub before: Option<String>,
    /// Filter messages by the run ID that generated them.
    pub run_id: Option<String>,
}

impl ListMessagesParams {
    pub fn builder() -> ListMessagesParamsBuilder {
        ListMessagesParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`list_run_steps`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ListRunStepsParams {
    /// The ID of the thread the run and run steps belong to.
    pub thread_id: String,
    /// The ID of the run the run steps belong to.
    pub run_id: String,
    /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
    pub limit: Option<i32>,
    /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
    pub order: Option<String>,
    /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
    pub after: Option<String>,
    /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
    pub before: Option<String>,
}

impl ListRunStepsParams {
    pub fn builder() -> ListRunStepsParamsBuilder {
        ListRunStepsParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`list_runs`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ListRunsParams {
    /// The ID of the thread the run belongs to.
    pub thread_id: String,
    /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
    pub limit: Option<i32>,
    /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
    pub order: Option<String>,
    /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
    pub after: Option<String>,
    /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
    pub before: Option<String>,
}

impl ListRunsParams {
    pub fn builder() -> ListRunsParamsBuilder {
        ListRunsParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`modify_assistant`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ModifyAssistantParams {
    /// The ID of the assistant to modify.
    pub assistant_id: String,
    pub modify_assistant_request: models::ModifyAssistantRequest,
}

impl ModifyAssistantParams {
    pub fn builder() -> ModifyAssistantParamsBuilder {
        ModifyAssistantParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`modify_message`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ModifyMessageParams {
    /// The ID of the thread to which this message belongs.
    pub thread_id: String,
    /// The ID of the message to modify.
    pub message_id: String,
    pub modify_message_request: models::ModifyMessageRequest,
}

impl ModifyMessageParams {
    pub fn builder() -> ModifyMessageParamsBuilder {
        ModifyMessageParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`modify_run`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ModifyRunParams {
    /// The ID of the [thread](/docs/api-reference/threads) that was run.
    pub thread_id: String,
    /// The ID of the run to modify.
    pub run_id: String,
    pub modify_run_request: models::ModifyRunRequest,
}

impl ModifyRunParams {
    pub fn builder() -> ModifyRunParamsBuilder {
        ModifyRunParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`modify_thread`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct ModifyThreadParams {
    /// The ID of the thread to modify. Only the `metadata` can be modified.
    pub thread_id: String,
    pub modify_thread_request: models::ModifyThreadRequest,
}

impl ModifyThreadParams {
    pub fn builder() -> ModifyThreadParamsBuilder {
        ModifyThreadParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`submit_tool_ouputs_to_run`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct SubmitToolOuputsToRunParams {
    /// The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
    pub thread_id: String,
    /// The ID of the run that requires the tool output submission.
    pub run_id: String,
    pub submit_tool_outputs_run_request: models::SubmitToolOutputsRunRequest,
}

impl SubmitToolOuputsToRunParams {
    pub fn builder() -> SubmitToolOuputsToRunParamsBuilder {
        SubmitToolOuputsToRunParamsBuilder::default()
    }
}

/// struct for typed errors of method [`cancel_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_thread`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateThreadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_thread_and_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateThreadAndRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_thread`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteThreadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_run_step`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRunStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_thread`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetThreadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_assistants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssistantsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_run_steps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRunStepsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_runs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRunsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modify_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModifyAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modify_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModifyMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modify_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModifyRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modify_thread`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModifyThreadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_tool_ouputs_to_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitToolOuputsToRunError {
    UnknownValue(serde_json::Value),
}

#[tracing::instrument]
pub async fn cancel_run(
    configuration: &configuration::Configuration, params: CancelRunParams,
) -> Result<models::RunObject, Error<CancelRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let run_id = params.run_id;

    debug!("Calling cancel_run...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/cancel",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        run_id = crate::apis::urlencode(run_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CancelRunError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_assistant(
    configuration: &configuration::Configuration, params: CreateAssistantParams,
) -> Result<models::AssistantObject, Error<CreateAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_assistant_request = params.create_assistant_request;

    debug!("Calling create_assistant...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/assistants", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_assistant_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateAssistantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_message(
    configuration: &configuration::Configuration, params: CreateMessageParams,
) -> Result<models::MessageObject, Error<CreateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let create_message_request = params.create_message_request;

    debug!("Calling create_message...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/messages",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_run(
    configuration: &configuration::Configuration, params: CreateRunParams,
) -> Result<models::RunObject, Error<CreateRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let create_run_request = params.create_run_request;

    debug!("Calling create_run...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_run_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateRunError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_thread(
    configuration: &configuration::Configuration, params: CreateThreadParams,
) -> Result<models::ThreadObject, Error<CreateThreadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_thread_request = params.create_thread_request;

    debug!("Calling create_thread...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/threads", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_thread_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateThreadError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn create_thread_and_run(
    configuration: &configuration::Configuration, params: CreateThreadAndRunParams,
) -> Result<models::RunObject, Error<CreateThreadAndRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_thread_and_run_request = params.create_thread_and_run_request;

    debug!("Calling create_thread_and_run...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/threads/runs", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_thread_and_run_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateThreadAndRunError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn delete_assistant(
    configuration: &configuration::Configuration, params: DeleteAssistantParams,
) -> Result<models::DeleteAssistantResponse, Error<DeleteAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_id = params.assistant_id;

    debug!("Calling delete_assistant...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/assistants/{assistant_id}",
        local_var_configuration.base_path,
        assistant_id = crate::apis::urlencode(assistant_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteAssistantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn delete_message(
    configuration: &configuration::Configuration, params: DeleteMessageParams,
) -> Result<models::DeleteMessageResponse, Error<DeleteMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let message_id = params.message_id;

    debug!("Calling delete_message...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/messages/{message_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        message_id = crate::apis::urlencode(message_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn delete_thread(
    configuration: &configuration::Configuration, params: DeleteThreadParams,
) -> Result<models::DeleteThreadResponse, Error<DeleteThreadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;

    debug!("Calling delete_thread...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteThreadError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn get_assistant(
    configuration: &configuration::Configuration, params: GetAssistantParams,
) -> Result<models::AssistantObject, Error<GetAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_id = params.assistant_id;

    debug!("Calling get_assistant...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/assistants/{assistant_id}",
        local_var_configuration.base_path,
        assistant_id = crate::apis::urlencode(assistant_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAssistantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn get_message(
    configuration: &configuration::Configuration, params: GetMessageParams,
) -> Result<models::MessageObject, Error<GetMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let message_id = params.message_id;

    debug!("Calling get_message...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/messages/{message_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        message_id = crate::apis::urlencode(message_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn get_run(
    configuration: &configuration::Configuration, params: GetRunParams,
) -> Result<models::RunObject, Error<GetRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let run_id = params.run_id;

    debug!("Calling get_run...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        run_id = crate::apis::urlencode(run_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRunError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn get_run_step(
    configuration: &configuration::Configuration, params: GetRunStepParams,
) -> Result<models::RunStepObject, Error<GetRunStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let run_id = params.run_id;
    let step_id = params.step_id;

    debug!("Calling get_run_step...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/steps/{step_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        run_id = crate::apis::urlencode(run_id),
        step_id = crate::apis::urlencode(step_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRunStepError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn get_thread(
    configuration: &configuration::Configuration, params: GetThreadParams,
) -> Result<models::ThreadObject, Error<GetThreadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;

    debug!("Calling get_thread...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetThreadError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn list_assistants(
    configuration: &configuration::Configuration, params: ListAssistantsParams,
) -> Result<models::ListAssistantsResponse, Error<ListAssistantsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let order = params.order;
    let after = params.after;
    let before = params.before;

    debug!("Calling list_assistants...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/assistants", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after {
        local_var_req_builder =
            local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before {
        local_var_req_builder =
            local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAssistantsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn list_messages(
    configuration: &configuration::Configuration, params: ListMessagesParams,
) -> Result<models::ListMessagesResponse, Error<ListMessagesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let limit = params.limit;
    let order = params.order;
    let after = params.after;
    let before = params.before;
    let run_id = params.run_id;

    debug!("Calling list_messages...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/messages",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after {
        local_var_req_builder =
            local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before {
        local_var_req_builder =
            local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = run_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("run_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListMessagesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn list_run_steps(
    configuration: &configuration::Configuration, params: ListRunStepsParams,
) -> Result<models::ListRunStepsResponse, Error<ListRunStepsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let run_id = params.run_id;
    let limit = params.limit;
    let order = params.order;
    let after = params.after;
    let before = params.before;

    debug!("Calling list_run_steps...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/steps",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        run_id = crate::apis::urlencode(run_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after {
        local_var_req_builder =
            local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before {
        local_var_req_builder =
            local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListRunStepsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn list_runs(
    configuration: &configuration::Configuration, params: ListRunsParams,
) -> Result<models::ListRunsResponse, Error<ListRunsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let limit = params.limit;
    let order = params.order;
    let after = params.after;
    let before = params.before;

    debug!("Calling list_runs...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after {
        local_var_req_builder =
            local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before {
        local_var_req_builder =
            local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListRunsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn modify_assistant(
    configuration: &configuration::Configuration, params: ModifyAssistantParams,
) -> Result<models::AssistantObject, Error<ModifyAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_id = params.assistant_id;
    let modify_assistant_request = params.modify_assistant_request;

    debug!("Calling modify_assistant...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/assistants/{assistant_id}",
        local_var_configuration.base_path,
        assistant_id = crate::apis::urlencode(assistant_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&modify_assistant_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModifyAssistantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn modify_message(
    configuration: &configuration::Configuration, params: ModifyMessageParams,
) -> Result<models::MessageObject, Error<ModifyMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let message_id = params.message_id;
    let modify_message_request = params.modify_message_request;

    debug!("Calling modify_message...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/messages/{message_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        message_id = crate::apis::urlencode(message_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&modify_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModifyMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn modify_run(
    configuration: &configuration::Configuration, params: ModifyRunParams,
) -> Result<models::RunObject, Error<ModifyRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let run_id = params.run_id;
    let modify_run_request = params.modify_run_request;

    debug!("Calling modify_run...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        run_id = crate::apis::urlencode(run_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&modify_run_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModifyRunError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn modify_thread(
    configuration: &configuration::Configuration, params: ModifyThreadParams,
) -> Result<models::ThreadObject, Error<ModifyThreadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let modify_thread_request = params.modify_thread_request;

    debug!("Calling modify_thread...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&modify_thread_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModifyThreadError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

#[tracing::instrument]
pub async fn submit_tool_ouputs_to_run(
    configuration: &configuration::Configuration, params: SubmitToolOuputsToRunParams,
) -> Result<models::RunObject, Error<SubmitToolOuputsToRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let thread_id = params.thread_id;
    let run_id = params.run_id;
    let submit_tool_outputs_run_request = params.submit_tool_outputs_run_request;

    debug!("Calling submit_tool_ouputs_to_run...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/submit_tool_outputs",
        local_var_configuration.base_path,
        thread_id = crate::apis::urlencode(thread_id),
        run_id = crate::apis::urlencode(run_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&submit_tool_outputs_run_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SubmitToolOuputsToRunError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
