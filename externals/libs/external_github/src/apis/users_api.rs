/*
 * GitHub v3 REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.4
 *
 * Generated by: https://openapi-generator.tech
 */

use super::configuration;
pub use super::Error;
use crate::{apis::ResponseContent, models};
use cached::proc_macro::cached;
use cached::Cached;
use cached::SizedCache;
use derive_builder::Builder;
use reqwest;
use serde::{Deserialize, Serialize};
use tracing::{debug, error, info, trace, warn};

#[macro_export]
macro_rules! generate_users_api_client_methods {
() => {
    /// users_slash_check_person_is_followed_by_authenticated method
    pub async fn users_slash_check_person_is_followed_by_authenticated(&self, params: UsersSlashCheckPersonIsFollowedByAuthenticatedParams) ->
    Result<(), Error<UsersSlashCheckPersonIsFollowedByAuthenticatedError>>
        {
        let result = crate::apis::users_api::users_slash_check_person_is_followed_by_authenticated(&self.config, params).await?;
        Ok(result)
    }
    /// users_slash_get_authenticated method
    pub async fn users_slash_get_authenticated(&self) ->
    Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetAuthenticatedError>>
        {
        let result = crate::apis::users_api::users_slash_get_authenticated(&self.config).await?;
        Ok(result)
    }
    /// users_slash_get_by_username method
    pub async fn users_slash_get_by_username(&self, params: UsersSlashGetByUsernameParams) ->
    Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetByUsernameError>>
        {
        let result = crate::apis::users_api::users_slash_get_by_username(&self.config, params).await?;
        Ok(result)
    }
    /// users_slash_list_followers_for_authenticated_user method
    pub async fn users_slash_list_followers_for_authenticated_user(&self, params: UsersSlashListFollowersForAuthenticatedUserParams) ->
    Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForAuthenticatedUserError>>
        {
        let result = crate::apis::users_api::users_slash_list_followers_for_authenticated_user(&self.config, params).await?;
        Ok(result)
    }
    /// users_slash_list_followers_for_user method
    pub async fn users_slash_list_followers_for_user(&self, params: UsersSlashListFollowersForUserParams) ->
    Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForUserError>>
        {
        let result = crate::apis::users_api::users_slash_list_followers_for_user(&self.config, params).await?;
        Ok(result)
    }
    /// users_slash_list_following_for_user method
    pub async fn users_slash_list_following_for_user(&self, params: UsersSlashListFollowingForUserParams) ->
    Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowingForUserError>>
        {
        let result = crate::apis::users_api::users_slash_list_following_for_user(&self.config, params).await?;
        Ok(result)
    }
    /// users_slash_list_gpg_keys_for_user method
    pub async fn users_slash_list_gpg_keys_for_user(&self, params: UsersSlashListGpgKeysForUserParams) ->
    Result<Vec<models::GpgKey>, Error<UsersSlashListGpgKeysForUserError>>
        {
        let result = crate::apis::users_api::users_slash_list_gpg_keys_for_user(&self.config, params).await?;
        Ok(result)
    }
    /// users_slash_list_public_keys_for_user method
    pub async fn users_slash_list_public_keys_for_user(&self, params: UsersSlashListPublicKeysForUserParams) ->
    Result<Vec<models::KeySimple>, Error<UsersSlashListPublicKeysForUserError>>
        {
        let result = crate::apis::users_api::users_slash_list_public_keys_for_user(&self.config, params).await?;
        Ok(result)
    }
    };
}

#[macro_export]
macro_rules! generate_users_api_client {
() => {
    use std::sync::Arc;
    use cached::SizedCache;
    use reqwest::Client;

    pub struct UsersApi<'a> {
        config: &'a Arc<configuration::Configuration>,
        client: Client,
    }

    impl<'a> UsersApi<'a> {
        pub fn new(config: &'a Arc<configuration::Configuration>) -> Self {
            UsersApi {
                config,
                client: Client::new(),
            }
        }
        /// users_slash_check_person_is_followed_by_authenticated method
        pub async  fn check_person_is_followed_by_authenticated(&self, params: UsersSlashCheckPersonIsFollowedByAuthenticatedParams) ->
            Result<, Error<UsersSlashCheckPersonIsFollowedByAuthenticatedError>> {
            let result = crate::apis::users_api::users_slash_check_person_is_followed_by_authenticated(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_get_authenticated method
        pub async  fn get_authenticated(&self) ->
            Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetAuthenticatedError>> {
            let result = crate::apis::users_api::users_slash_get_authenticated(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_get_by_username method
        pub async  fn get_by_username(&self, params: UsersSlashGetByUsernameParams) ->
            Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetByUsernameError>> {
            let result = crate::apis::users_api::users_slash_get_by_username(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_list_followers_for_authenticated_user method
        pub async  fn list_followers_for_authenticated_user(&self, params: UsersSlashListFollowersForAuthenticatedUserParams) ->
            Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForAuthenticatedUserError>> {
            let result = crate::apis::users_api::users_slash_list_followers_for_authenticated_user(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_list_followers_for_user method
        pub async  fn list_followers_for_user(&self, params: UsersSlashListFollowersForUserParams) ->
            Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForUserError>> {
            let result = crate::apis::users_api::users_slash_list_followers_for_user(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_list_following_for_user method
        pub async  fn list_following_for_user(&self, params: UsersSlashListFollowingForUserParams) ->
            Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowingForUserError>> {
            let result = crate::apis::users_api::users_slash_list_following_for_user(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_list_gpg_keys_for_user method
        pub async  fn list_gpg_keys_for_user(&self, params: UsersSlashListGpgKeysForUserParams) ->
            Result<Vec<models::GpgKey>, Error<UsersSlashListGpgKeysForUserError>> {
            let result = crate::apis::users_api::users_slash_list_gpg_keys_for_user(&self.config, params).await?;
            Ok(result)
        }
        /// users_slash_list_public_keys_for_user method
        pub async  fn list_public_keys_for_user(&self, params: UsersSlashListPublicKeysForUserParams) ->
            Result<Vec<models::KeySimple>, Error<UsersSlashListPublicKeysForUserError>> {
            let result = crate::apis::users_api::users_slash_list_public_keys_for_user(&self.config, params).await?;
            Ok(result)
        }
    }
}
}

/// struct for passing parameters to the method [`users_slash_check_person_is_followed_by_authenticated`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashCheckPersonIsFollowedByAuthenticatedParams {
    /// The handle for the GitHub user account.
    pub username: String,
}

impl UsersSlashCheckPersonIsFollowedByAuthenticatedParams {
    pub fn builder() -> UsersSlashCheckPersonIsFollowedByAuthenticatedParamsBuilder {
        UsersSlashCheckPersonIsFollowedByAuthenticatedParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`users_slash_get_by_username`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashGetByUsernameParams {
    /// The handle for the GitHub user account.
    pub username: String,
}

impl UsersSlashGetByUsernameParams {
    pub fn builder() -> UsersSlashGetByUsernameParamsBuilder {
        UsersSlashGetByUsernameParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`users_slash_list_followers_for_authenticated_user`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashListFollowersForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl UsersSlashListFollowersForAuthenticatedUserParams {
    pub fn builder() -> UsersSlashListFollowersForAuthenticatedUserParamsBuilder {
        UsersSlashListFollowersForAuthenticatedUserParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`users_slash_list_followers_for_user`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashListFollowersForUserParams {
    /// The handle for the GitHub user account.
    pub username: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl UsersSlashListFollowersForUserParams {
    pub fn builder() -> UsersSlashListFollowersForUserParamsBuilder {
        UsersSlashListFollowersForUserParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`users_slash_list_following_for_user`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashListFollowingForUserParams {
    /// The handle for the GitHub user account.
    pub username: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl UsersSlashListFollowingForUserParams {
    pub fn builder() -> UsersSlashListFollowingForUserParamsBuilder {
        UsersSlashListFollowingForUserParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`users_slash_list_gpg_keys_for_user`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashListGpgKeysForUserParams {
    /// The handle for the GitHub user account.
    pub username: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl UsersSlashListGpgKeysForUserParams {
    pub fn builder() -> UsersSlashListGpgKeysForUserParamsBuilder {
        UsersSlashListGpgKeysForUserParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`users_slash_list_public_keys_for_user`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq, Eq)]
#[builder(setter(strip_option, into), default)]
pub struct UsersSlashListPublicKeysForUserParams {
    /// The handle for the GitHub user account.
    pub username: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl UsersSlashListPublicKeysForUserParams {
    pub fn builder() -> UsersSlashListPublicKeysForUserParamsBuilder {
        UsersSlashListPublicKeysForUserParamsBuilder::default()
    }
}

/// struct for typed errors of method [`users_slash_check_person_is_followed_by_authenticated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCheckPersonIsFollowedByAuthenticatedError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_authenticated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetAuthenticatedError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_by_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetByUsernameError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_followers_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowersForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_followers_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowersForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_following_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowingForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_gpg_keys_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListGpgKeysForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_public_keys_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListPublicKeysForUserError {
    UnknownValue(serde_json::Value),
}

///
#[tracing::instrument]
pub async fn users_slash_check_person_is_followed_by_authenticated(
    configuration: &configuration::Configuration,
    params: UsersSlashCheckPersonIsFollowedByAuthenticatedParams,
) -> Result<(), Error<UsersSlashCheckPersonIsFollowedByAuthenticatedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;

    debug!("Calling users_slash_check_person_is_followed_by_authenticated...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/user/following/{username}",
        local_var_configuration.base_path,
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UsersSlashCheckPersonIsFollowedByAuthenticatedError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// OAuth app tokens and personal access tokens (classic) need the `user` scope in order for the response to include private profile information.
#[tracing::instrument]
pub async fn users_slash_get_authenticated(
    configuration: &configuration::Configuration,
) -> Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetAuthenticatedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    debug!("Calling users_slash_get_authenticated...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashGetAuthenticatedError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provides publicly available information about someone with a GitHub account.  The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to
#[tracing::instrument]
pub async fn users_slash_get_by_username(
    configuration: &configuration::Configuration, params: UsersSlashGetByUsernameParams,
) -> Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetByUsernameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;

    debug!("Calling users_slash_get_by_username...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{username}",
        local_var_configuration.base_path,
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashGetByUsernameError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the people following the authenticated user.
#[tracing::instrument]
pub async fn users_slash_list_followers_for_authenticated_user(
    configuration: &configuration::Configuration,
    params: UsersSlashListFollowersForAuthenticatedUserParams,
) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling users_slash_list_followers_for_authenticated_user...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/followers", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashListFollowersForAuthenticatedUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the people following the specified user.
#[tracing::instrument]
pub async fn users_slash_list_followers_for_user(
    configuration: &configuration::Configuration, params: UsersSlashListFollowersForUserParams,
) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling users_slash_list_followers_for_user...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{username}/followers",
        local_var_configuration.base_path,
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashListFollowersForUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the people who the specified user follows.
#[tracing::instrument]
pub async fn users_slash_list_following_for_user(
    configuration: &configuration::Configuration, params: UsersSlashListFollowingForUserParams,
) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowingForUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling users_slash_list_following_for_user...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{username}/following",
        local_var_configuration.base_path,
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashListFollowingForUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the GPG keys for a user. This information is accessible by anyone.
#[tracing::instrument]
pub async fn users_slash_list_gpg_keys_for_user(
    configuration: &configuration::Configuration, params: UsersSlashListGpgKeysForUserParams,
) -> Result<Vec<models::GpgKey>, Error<UsersSlashListGpgKeysForUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling users_slash_list_gpg_keys_for_user...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{username}/gpg_keys",
        local_var_configuration.base_path,
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashListGpgKeysForUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
#[tracing::instrument]
pub async fn users_slash_list_public_keys_for_user(
    configuration: &configuration::Configuration, params: UsersSlashListPublicKeysForUserParams,
) -> Result<Vec<models::KeySimple>, Error<UsersSlashListPublicKeysForUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling users_slash_list_public_keys_for_user...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{username}/keys",
        local_var_configuration.base_path,
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UsersSlashListPublicKeysForUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
