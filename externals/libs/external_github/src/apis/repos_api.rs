/*
 * GitHub v3 REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.4
 *
 * Generated by: https://openapi-generator.tech
 */

use super::configuration;
pub use super::Error;
use crate::{apis::ResponseContent, models};
use cached::proc_macro::cached;
use cached::Cached;
use cached::SizedCache;
use derive_builder::Builder;
use reqwest;
use serde::{Deserialize, Serialize};
use tracing::{debug, error, info, trace, warn};

#[macro_export]
macro_rules! generate_repos_api_client_methods {
    () => {
        /// repos_slash_create_commit_comment method
        pub async fn repos_slash_create_commit_comment(
            &self, params: ReposSlashCreateCommitCommentParams,
        ) -> Result<models::CommitComment, Error<ReposSlashCreateCommitCommentError>> {
            let result =
                crate::apis::repos_api::repos_slash_create_commit_comment(&self.config, params)
                    .await?;
            Ok(result)
        }
        /// repos_slash_get_commit method
        pub async fn repos_slash_get_commit(
            &self, params: ReposSlashGetCommitParams,
        ) -> Result<models::Commit, Error<ReposSlashGetCommitError>> {
            let result =
                crate::apis::repos_api::repos_slash_get_commit(&self.config, params).await?;
            Ok(result)
        }
        /// repos_slash_list_comments_for_commit method
        pub async fn repos_slash_list_comments_for_commit(
            &self, params: ReposSlashListCommentsForCommitParams,
        ) -> Result<Vec<models::CommitComment>, Error<ReposSlashListCommentsForCommitError>> {
            let result =
                crate::apis::repos_api::repos_slash_list_comments_for_commit(&self.config, params)
                    .await?;
            Ok(result)
        }
        /// repos_slash_list_commit_comments_for_repo method
        pub async fn repos_slash_list_commit_comments_for_repo(
            &self, params: ReposSlashListCommitCommentsForRepoParams,
        ) -> Result<Vec<models::CommitComment>, Error<ReposSlashListCommitCommentsForRepoError>> {
            let result = crate::apis::repos_api::repos_slash_list_commit_comments_for_repo(
                &self.config,
                params,
            )
            .await?;
            Ok(result)
        }
        /// repos_slash_list_commit_statuses_for_ref method
        pub async fn repos_slash_list_commit_statuses_for_ref(
            &self, params: ReposSlashListCommitStatusesForRefParams,
        ) -> Result<Vec<models::Status>, Error<ReposSlashListCommitStatusesForRefError>> {
            let result = crate::apis::repos_api::repos_slash_list_commit_statuses_for_ref(
                &self.config,
                params,
            )
            .await?;
            Ok(result)
        }
        /// repos_slash_list_commits method
        pub async fn repos_slash_list_commits(
            &self, params: ReposSlashListCommitsParams,
        ) -> Result<Vec<models::Commit>, Error<ReposSlashListCommitsError>> {
            let result =
                crate::apis::repos_api::repos_slash_list_commits(&self.config, params).await?;
            Ok(result)
        }
        /// repos_slash_list_pull_requests_associated_with_commit method
        pub async fn repos_slash_list_pull_requests_associated_with_commit(
            &self, params: ReposSlashListPullRequestsAssociatedWithCommitParams,
        ) -> Result<
            Vec<models::PullRequestSimple>,
            Error<ReposSlashListPullRequestsAssociatedWithCommitError>,
        > {
            let result =
                crate::apis::repos_api::repos_slash_list_pull_requests_associated_with_commit(
                    &self.config,
                    params,
                )
                .await?;
            Ok(result)
        }
    };
}

#[macro_export]
macro_rules! generate_repos_api_client {
    () => {
        use cached::SizedCache;
        use reqwest::Client;
        use std::sync::Arc;

        pub struct ReposApi<'a> {
            config: &'a Arc<configuration::Configuration>,
            client: Client,
        }

        impl<'a> ReposApi<'a> {
            pub fn new(config: &'a Arc<configuration::Configuration>) -> Self {
                ReposApi {
                    config,
                    client: Client::new(),
                }
            }
            /// repos_slash_create_commit_comment method
            pub async fn create_commit_comment(
                &self, params: ReposSlashCreateCommitCommentParams,
            ) -> Result<models::CommitComment, Error<ReposSlashCreateCommitCommentError>> {
                let result =
                    crate::apis::repos_api::repos_slash_create_commit_comment(&self.config, params)
                        .await?;
                Ok(result)
            }
            /// repos_slash_get_commit method
            pub async fn get_commit(
                &self, params: ReposSlashGetCommitParams,
            ) -> Result<models::Commit, Error<ReposSlashGetCommitError>> {
                let result =
                    crate::apis::repos_api::repos_slash_get_commit(&self.config, params).await?;
                Ok(result)
            }
            /// repos_slash_list_comments_for_commit method
            pub async fn list_comments_for_commit(
                &self, params: ReposSlashListCommentsForCommitParams,
            ) -> Result<Vec<models::CommitComment>, Error<ReposSlashListCommentsForCommitError>>
            {
                let result = crate::apis::repos_api::repos_slash_list_comments_for_commit(
                    &self.config,
                    params,
                )
                .await?;
                Ok(result)
            }
            /// repos_slash_list_commit_comments_for_repo method
            pub async fn list_commit_comments_for_repo(
                &self, params: ReposSlashListCommitCommentsForRepoParams,
            ) -> Result<Vec<models::CommitComment>, Error<ReposSlashListCommitCommentsForRepoError>>
            {
                let result = crate::apis::repos_api::repos_slash_list_commit_comments_for_repo(
                    &self.config,
                    params,
                )
                .await?;
                Ok(result)
            }
            /// repos_slash_list_commit_statuses_for_ref method
            pub async fn list_commit_statuses_for_ref(
                &self, params: ReposSlashListCommitStatusesForRefParams,
            ) -> Result<Vec<models::Status>, Error<ReposSlashListCommitStatusesForRefError>> {
                let result = crate::apis::repos_api::repos_slash_list_commit_statuses_for_ref(
                    &self.config,
                    params,
                )
                .await?;
                Ok(result)
            }
            /// repos_slash_list_commits method
            pub async fn list_commits(
                &self, params: ReposSlashListCommitsParams,
            ) -> Result<Vec<models::Commit>, Error<ReposSlashListCommitsError>> {
                let result =
                    crate::apis::repos_api::repos_slash_list_commits(&self.config, params).await?;
                Ok(result)
            }
            /// repos_slash_list_pull_requests_associated_with_commit method
            pub async fn list_pull_requests_associated_with_commit(
                &self, params: ReposSlashListPullRequestsAssociatedWithCommitParams,
            ) -> Result<
                Vec<models::PullRequestSimple>,
                Error<ReposSlashListPullRequestsAssociatedWithCommitError>,
            > {
                let result =
                    crate::apis::repos_api::repos_slash_list_pull_requests_associated_with_commit(
                        &self.config,
                        params,
                    )
                    .await?;
                Ok(result)
            }
        }
    };
}

/// struct for passing parameters to the method [`repos_slash_create_commit_comment`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashCreateCommitCommentParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// The SHA of the commit.
    pub commit_sha: String,
    pub repos_create_commit_comment_request: models::ReposCreateCommitCommentRequest,
}

impl ReposSlashCreateCommitCommentParams {
    pub fn builder() -> ReposSlashCreateCommitCommentParamsBuilder {
        ReposSlashCreateCommitCommentParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`repos_slash_get_commit`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashGetCommitParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.
    pub r#ref: String,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
}

impl ReposSlashGetCommitParams {
    pub fn builder() -> ReposSlashGetCommitParamsBuilder {
        ReposSlashGetCommitParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`repos_slash_list_comments_for_commit`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashListCommentsForCommitParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// The SHA of the commit.
    pub commit_sha: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl ReposSlashListCommentsForCommitParams {
    pub fn builder() -> ReposSlashListCommentsForCommitParamsBuilder {
        ReposSlashListCommentsForCommitParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`repos_slash_list_commit_comments_for_repo`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashListCommitCommentsForRepoParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl ReposSlashListCommitCommentsForRepoParams {
    pub fn builder() -> ReposSlashListCommitCommentsForRepoParamsBuilder {
        ReposSlashListCommitCommentsForRepoParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`repos_slash_list_commit_statuses_for_ref`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashListCommitStatusesForRefParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.
    pub r#ref: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl ReposSlashListCommitStatusesForRefParams {
    pub fn builder() -> ReposSlashListCommitStatusesForRefParamsBuilder {
        ReposSlashListCommitStatusesForRefParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`repos_slash_list_commits`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashListCommitsParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// SHA or branch to start listing commits from. Default: the repository’s default branch (usually `main`).
    pub sha: Option<String>,
    /// Only commits containing this file path will be returned.
    pub path: Option<String>,
    /// GitHub username or email address to use to filter by commit author.
    pub author: Option<String>,
    /// GitHub username or email address to use to filter by commit committer.
    pub committer: Option<String>,
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
    pub since: Option<String>,
    /// Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
    pub until: Option<String>,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl ReposSlashListCommitsParams {
    pub fn builder() -> ReposSlashListCommitsParamsBuilder {
        ReposSlashListCommitsParamsBuilder::default()
    }
}

/// struct for passing parameters to the method [`repos_slash_list_pull_requests_associated_with_commit`]
#[derive(Clone, Debug, Builder, Default, Serialize, PartialEq)]
#[builder(setter(strip_option, into), default)]
pub struct ReposSlashListPullRequestsAssociatedWithCommitParams {
    /// The account owner of the repository. The name is not case sensitive.
    pub owner: String,
    /// The name of the repository without the `.git` extension. The name is not case sensitive.
    pub repo: String,
    /// The SHA of the commit.
    pub commit_sha: String,
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub per_page: Option<i32>,
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub page: Option<i32>,
}

impl ReposSlashListPullRequestsAssociatedWithCommitParams {
    pub fn builder() -> ReposSlashListPullRequestsAssociatedWithCommitParamsBuilder {
        ReposSlashListPullRequestsAssociatedWithCommitParamsBuilder::default()
    }
}

/// struct for typed errors of method [`repos_slash_create_commit_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashCreateCommitCommentError {
    Status403(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repos_slash_get_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashGetCommitError {
    Status404(models::BasicError),
    Status409(models::BasicError),
    Status422(models::ValidationError),
    Status500(models::BasicError),
    Status503(models::ReposGetCommit503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repos_slash_list_comments_for_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashListCommentsForCommitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repos_slash_list_commit_comments_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashListCommitCommentsForRepoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repos_slash_list_commit_statuses_for_ref`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashListCommitStatusesForRefError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repos_slash_list_commits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashListCommitsError {
    Status400(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repos_slash_list_pull_requests_associated_with_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSlashListPullRequestsAssociatedWithCommitError {
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// Create a comment for a commit using its `:commit_sha`.  This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more info
#[tracing::instrument]
pub async fn repos_slash_create_commit_comment(
    configuration: &configuration::Configuration, params: ReposSlashCreateCommitCommentParams,
) -> Result<models::CommitComment, Error<ReposSlashCreateCommitCommentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let commit_sha = params.commit_sha;
    let repos_create_commit_comment_request = params.repos_create_commit_comment_request;

    debug!("Calling repos_slash_create_commit_comment...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/repos/{owner}/{repo}/commits/{commit_sha}/comments",
        local_var_configuration.base_path,
        owner = crate::apis::urlencode(owner),
        repo = crate::apis::urlencode(repo),
        commit_sha = crate::apis::urlencode(commit_sha)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&repos_create_commit_comment_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashCreateCommitCommentError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.  > [!NOTE] > If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining f
#[tracing::instrument]
pub async fn repos_slash_get_commit(
    configuration: &configuration::Configuration, params: ReposSlashGetCommitParams,
) -> Result<models::Commit, Error<ReposSlashGetCommitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let r#ref = params.r#ref;
    let page = params.page;
    let per_page = params.per_page;

    debug!("Calling repos_slash_get_commit...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/commits/{ref}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo), ref=crate::apis::urlencode(r#ref));
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashGetCommitError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the comments for a specified commit.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github-commitcomment.raw+json`**: Retur
#[tracing::instrument]
pub async fn repos_slash_list_comments_for_commit(
    configuration: &configuration::Configuration, params: ReposSlashListCommentsForCommitParams,
) -> Result<Vec<models::CommitComment>, Error<ReposSlashListCommentsForCommitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let commit_sha = params.commit_sha;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling repos_slash_list_comments_for_commit...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/repos/{owner}/{repo}/commits/{commit_sha}/comments",
        local_var_configuration.base_path,
        owner = crate::apis::urlencode(owner),
        repo = crate::apis::urlencode(repo),
        commit_sha = crate::apis::urlencode(commit_sha)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashListCommentsForCommitError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the commit comments for a specified repository. Comments are ordered by ascending ID.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`applic
#[tracing::instrument]
pub async fn repos_slash_list_commit_comments_for_repo(
    configuration: &configuration::Configuration, params: ReposSlashListCommitCommentsForRepoParams,
) -> Result<Vec<models::CommitComment>, Error<ReposSlashListCommitCommentsForRepoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling repos_slash_list_commit_comments_for_repo...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/repos/{owner}/{repo}/comments",
        local_var_configuration.base_path,
        owner = crate::apis::urlencode(owner),
        repo = crate::apis::urlencode(repo)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashListCommitCommentsForRepoError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.  This resource is also available via a legacy route: `GET /r
#[tracing::instrument]
pub async fn repos_slash_list_commit_statuses_for_ref(
    configuration: &configuration::Configuration, params: ReposSlashListCommitStatusesForRefParams,
) -> Result<Vec<models::Status>, Error<ReposSlashListCommitStatusesForRefError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let r#ref = params.r#ref;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling repos_slash_list_commit_statuses_for_ref...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/commits/{ref}/statuses", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo), ref=crate::apis::urlencode(r#ref));
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashListCommitStatusesForRefError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` |
#[tracing::instrument]
pub async fn repos_slash_list_commits(
    configuration: &configuration::Configuration, params: ReposSlashListCommitsParams,
) -> Result<Vec<models::Commit>, Error<ReposSlashListCommitsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let sha = params.sha;
    let path = params.path;
    let author = params.author;
    let committer = params.committer;
    let since = params.since;
    let until = params.until;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling repos_slash_list_commits...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/repos/{owner}/{repo}/commits",
        local_var_configuration.base_path,
        owner = crate::apis::urlencode(owner),
        repo = crate::apis::urlencode(repo)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sha {
        local_var_req_builder = local_var_req_builder.query(&[("sha", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = path {
        local_var_req_builder =
            local_var_req_builder.query(&[("path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = author {
        local_var_req_builder =
            local_var_req_builder.query(&[("author", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = committer {
        local_var_req_builder =
            local_var_req_builder.query(&[("committer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder =
            local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = until {
        local_var_req_builder =
            local_var_req_builder.query(&[("until", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashListCommitsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, will only return open pull requests associated with the commit.  To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter t
#[tracing::instrument]
pub async fn repos_slash_list_pull_requests_associated_with_commit(
    configuration: &configuration::Configuration,
    params: ReposSlashListPullRequestsAssociatedWithCommitParams,
) -> Result<
    Vec<models::PullRequestSimple>,
    Error<ReposSlashListPullRequestsAssociatedWithCommitError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let owner = params.owner;
    let repo = params.repo;
    let commit_sha = params.commit_sha;
    let per_page = params.per_page;
    let page = params.page;

    debug!("Calling repos_slash_list_pull_requests_associated_with_commit...");

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/repos/{owner}/{repo}/commits/{commit_sha}/pulls",
        local_var_configuration.base_path,
        owner = crate::apis::urlencode(owner),
        repo = crate::apis::urlencode(repo),
        commit_sha = crate::apis::urlencode(commit_sha)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReposSlashListPullRequestsAssociatedWithCommitError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
